"""
-- INTRODUCTION --
An IDA Pro plug-in to classify a malware into nine families defined by the 2015 Microsoft Malware Classification Challenge.

-- USAGE --
This script must be located in the same folder as `generator.py`.

-- HELP --
See: https://github.com/czs108/Microsoft-Malware-Classification
"""

from pathlib import Path
import zlib
import joblib
import re

import pandas as pd
import numpy as np

import idaapi
import ida_loader
import ida_diskio

from generator import Generator


class Reader:
    def __init__(self, file: str) -> None:
        self._file: str = file

    def bytes(self) -> list[str]:
        with Path(self._file + ".bytes").open() as file:
            data = file.read()
        items = data.split()
        byte_list = []
        for item in items:
            if len(item) == 2 and item != "??":
                byte_list.append(item)
        return byte_list

    def asm(self) -> str:
        with Path(self._file + ".asm").open(encoding="utf-8", errors="ignore") as file:
            return file.read()

    def asm_lines(self) -> list[str]:
        with Path(self._file + ".asm").open(encoding="utf-8", errors="ignore") as file:
            return file.readlines()


class Section:
    _sctn_rgx: re.Pattern = re.compile(r"([A-Za-z]+):[\dA-F]{8}\s+;\s+Virtual\s+size\s+:\s+[\dA-F]{8}\s+\(\s*(\d+)\.[\s\S]+?Section\s+size\s+in\s+file\s+:\s+[\dA-F]{8}\s+\(\s*(\d+)\.[\s\S]+?;\s+Flags\s+[\dA-F]{8}:[\s\S]+?\s+((?:Executable|Readable|Writable|\s)+)", flags=re.IGNORECASE)

    def __init__(self) -> None:
        self.name: str = ""
        self.virtual_size: int = 0
        self.raw_size: int = 0
        self.executable: bool = False
        self.writable: bool = False

    @classmethod
    def load(cls, asm: str) -> list[Section]:
        sctns = []
        for attr in cls._sctn_rgx.findall(asm):
            sctn = Section()
            sctn.name, sctn.virtual_size, sctn.raw_size, access = \
                attr[0].lower(), int(attr[1]), int(attr[2]), set(attr[3].split())
            if "Executable" in access:
                sctn.executable = True
            if "Writable" in access:
                sctn.writable = True
            sctns.append(sctn)
        return sctns


class Extractor:
    _sctn_cols: tuple[str] = ("idata-Raw", "text-Raw", "data-Virtual", "data-Ratio", "text-Virtual",
                                "data-Raw", "idata-Virtual", "text-Ratio", "idata-Ratio", "bss-Virtual",
                                "bss-Ratio", "rdata-Ratio", "rdata-Virtual", "rdata-Raw", "bss-Raw",
                                "code-Raw", "code-Ratio", "tls-Raw", "code-Virtual", "tls-Ratio",
                                "tls-Virtual", "rata-Raw", "rata-Virtual", "rata-Ratio", "zenc-Ratio")

    def __init__(self, file: str) -> None:
        self._file: str = file
        self._id: str = Path(file).name

    def extract(self) -> pd.DataFrame:
        size, rwe = self._section_attributions()
        selected_size = pd.DataFrame(index=size.index, columns=self._sctn_cols)
        for col in size.columns:
            if col in selected_size.columns:
                selected_size.at[self._id, col] = size.at[self._id, col]
        return pd.concat([selected_size.fillna(0), rwe, self._content_complexity()], axis="columns")

    def _content_complexity(self) -> pd.DataFrame:
        df = pd.DataFrame(
            columns=["ID", "Asm-Len", "Zip-Asm-Len", "Asm-Zip-Ratio", "Byte-Len", "Zip-Byte-Len", "Byte-Zip-Ratio"],
            dtype=float).set_index("ID")

        reader = Reader(self._file)
        asm = reader.asm().encode("utf-8")
        bytes = " ".join([str(byte) for byte in reader.bytes()]).encode("utf-8")
        df.at[self._id, "Asm-Len"] = len(asm)
        df.at[self._id, "Zip-Asm-Len"] = len(zlib.compress(asm))
        df.at[self._id, "Byte-Len"] = len(bytes)
        df.at[self._id, "Zip-Byte-Len"] = len(zlib.compress(bytes))

        df[["Asm-Len", "Zip-Asm-Len", "Byte-Len", "Zip-Byte-Len"]] = \
            df[["Asm-Len", "Zip-Asm-Len", "Byte-Len", "Zip-Byte-Len"]].astype(int)
        df["Asm-Zip-Ratio"] = (df["Asm-Len"] / df["Zip-Asm-Len"]).round(5)
        df["Byte-Zip-Ratio"] = (df["Byte-Len"] / df["Zip-Byte-Len"]).round(5)
        return df

    def _section_attributions(self) -> tuple[pd.DataFrame, pd.DataFrame]:
        rwe_cols = [f"{i}-{j}" for i in ["Executable", "Writable", "Readable"] for j in ["Virtual", "Raw", "Ratio"]]
        rwe = pd.DataFrame(columns=["ID"] + rwe_cols, dtype=float).set_index("ID")
        sctn = pd.DataFrame(columns=["ID"], dtype=float).set_index("ID")

        sctn_int_cols = set()

        def save_by_sections(attr: Section) -> None:
            sctn.at[self._id, f"{attr.name}-Virtual"] = attr.virtual_size
            sctn.at[self._id, f"{attr.name}-Raw",] = attr.raw_size
            sctn.at[self._id, f"{attr.name}-Ratio",] = round(attr.raw_size / attr.virtual_size, 5)
            sctn_int_cols.update([f"{attr.name}-Virtual", f"{attr.name}-Raw"])

        def save_by_access(attr: Section) -> None:
            rwe.at[self._id, "Readable-Virtual"] += attr.virtual_size
            rwe.at[self._id, "Readable-Raw"] += attr.raw_size
            if attr.writable:
                rwe.at[self._id, "Writable-Virtual"] += attr.virtual_size
                rwe.at[self._id, "Writable-Raw"] += attr.raw_size
            if attr.executable:
                rwe.at[self._id, "Executable-Virtual"] += attr.virtual_size
                rwe.at[self._id, "Executable-Raw"] += attr.raw_size

        rwe.loc[self._id, :] = 0
        sctn.loc[self._id, :] = 0
        for attr in Section.load(Reader(self._file).asm()):
            save_by_sections(attr)
            save_by_access(attr)

        sctn.fillna(0, inplace=True)
        sctn_int_cols = list(sctn_int_cols)
        sctn[sctn_int_cols] = sctn[sctn_int_cols].astype(int)

        rwe.fillna(0, inplace=True)
        rwe_int_cols = [i for i in rwe.columns if "-Virtual" in i or "-Raw" in i]
        rwe[rwe_int_cols] = rwe[rwe_int_cols].astype(int)

        rwe["Readable-Ratio"] = (rwe["Readable-Raw"] / rwe["Readable-Virtual"]).round(5)
        rwe["Writable-Ratio"] = (rwe["Writable-Raw"] / rwe["Writable-Virtual"]).round(5)
        rwe["Executable-Ratio"] = (rwe["Executable-Raw"] / rwe["Executable-Virtual"]).round(5)
        return sctn, rwe.fillna(0)


class MalwareClassifier(idaapi.plugin_t):
    flags: int = idaapi.PLUGIN_UNL
    comment: str = "This plug-in can calculate the probability that it belongs to each malware family defined by the 2015 Microsoft Malware Classification Challenge."
    help: str = "See: https://github.com/czs108/Microsoft-Malware-Classification"
    wanted_name: str = "2015 Microsoft Malware Classifier"
    wanted_hotkey: str = "Alt-F8"

    def init(self) -> int:
        self._file: str = ida_loader.get_path(ida_loader.PATH_TYPE_IDB)[:-len(".idb")]
        self._classes: tuple[str] = \
            ("Ramnit", "Lollipop", "Kelihos_ver3", "Vundo", "Simda", "Tracur", "Kelihos_ver1", "Obfuscator.ACY", "Gatak")
        return idaapi.PLUGIN_OK

    def run(self, arg: int) -> None:
        self._gene_data()
        plugin_folder = Path(ida_diskio.idadir("plugins"))
        X = Extractor(self._file).extract()
        classifier = joblib.load(plugin_folder.joinpath("tpot_exported_ida_clf.joblib"))
        proba = classifier.predict_proba(X)[0]
        for i in np.argsort(proba)[::-1]:
            idaapi.msg("{:04.2f} -> {}\n".format(proba[i], self._classes[i]))

    def term(self) -> None:
        pass

    def _gene_data(self) -> None:
        generator = Generator(self._file)
        generator.asm()
        generator.bytes()


def PLUGIN_ENTRY() -> MalwareClassifier:
    return MalwareClassifier()
